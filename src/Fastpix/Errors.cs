/* 
 * This file is auto-generated.
 * Do not edit this file manually.
 * Your changes will be overwritten during the next generation.
 */
#nullable enable
namespace Fastpix
{
    using Fastpix.Hooks;
    using Fastpix.Models.Components;
    using Fastpix.Models.Errors;
    using Fastpix.Models.Requests;
    using Fastpix.Utils;
    using Fastpix.Utils.Retries;
    using Newtonsoft.Json;
    using System;
    using System.Collections.Generic;
    using System.Net.Http;
    using System.Net.Http.Headers;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// Operations involving errors
    /// </summary>
    public interface IErrors
    {

        /// <summary>
        /// List errors
        /// 
        /// <remarks>
        /// This endpoint returns the total number of playback errors that occurred, along with the total number of views captured, based on the specified timespan and filters. It provides insights into the overall playback quality and helps identify potential issues that may impact viewer experience. <br/>
        /// <br/>
        /// <br/>
        /// #### Key fields in response<br/>
        /// <br/>
        /// * **percentage:** The percentage of views affected by the specific error. <br/>
        /// * **uniqueViewersEffectedPercentage:** The percentage of unique viewers affected by the specific error (available only in the topErrors section). <br/>
        /// * **notes:** Additional notes or information about the specific error. <br/>
        /// * **message:** The error message or description. <br/>
        /// * **lastSeen:** The timestamp of when the error was last observed. <br/>
        /// * **id:** The unique identifier for the specific error. <br/>
        /// * **description:** A description of the specific error. <br/>
        /// * **count:** The number of occurrences of the specific error. <br/>
        /// * **code:** The error code associated with the specific error. <br/>
        /// <br/>
        /// <br/>
        /// Related guide: &lt;a href=&quot;https://docs.fastpix.io/docs/track-playback-errors&quot;&gt;Troubleshoot errors&lt;/a&gt;<br/>
        /// 
        /// </remarks>
        /// </summary>
        Task<ListErrorsResponse> ListAsync(ListErrorsTimespan? timespan = null, string? filterby = null, long? limit = 1, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null);
    }

    /// <summary>
    /// Operations involving errors
    /// </summary>
    public class Errors: IErrors
    {
        public SDKConfig SDKConfiguration { get; private set; }

        private const string _language = Constants.Language;
        private const string _sdkVersion = Constants.SdkVersion;
        private const string _sdkGenVersion = Constants.SdkGenVersion;
        private const string _openapiDocVersion = Constants.OpenApiDocVersion;

        public Errors(SDKConfig config)
        {
            SDKConfiguration = config;
        }

        public async Task<ListErrorsResponse> ListAsync(ListErrorsTimespan? timespan = null, string? filterby = null, long? limit = 1, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null)
        {
            var request = new ListErrorsRequest()
            {
                Timespan = timespan,
                Filterby = filterby,
                Limit = limit,
            };
            string baseUrl = this.SDKConfiguration.GetTemplatedServerUrl();
            var urlString = URLBuilder.Build(baseUrl, "/data/errors", request, null);

            var httpRequest = new HttpRequestMessage(HttpMethod.Get, urlString);
            httpRequest.Headers.Add("user-agent", SDKConfiguration.UserAgent);

            if (SDKConfiguration.SecuritySource != null)
            {
                httpRequest = new SecurityMetadata(SDKConfiguration.SecuritySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext(SDKConfiguration, baseUrl, "list_errors", null, SDKConfiguration.SecuritySource, cancellationToken);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);
            if (retryConfig == null)
            {
                if (this.SDKConfiguration.RetryConfig != null)
                {
                    retryConfig = this.SDKConfiguration.RetryConfig;
                }
                else
                {
                    var backoff = new BackoffStrategy(
                        initialIntervalMs: 1000L,
                        maxIntervalMs: 10000L,
                        maxElapsedTimeMs: 3600000L,
                        exponent: 1.5
                    );
                    retryConfig = new RetryConfig(
                        strategy: RetryConfig.RetryStrategy.BACKOFF,
                        backoff: backoff,
                        retryConnectionErrors: true
                    );
                }
            }

            List<string> statusCodes = new List<string>
            {
                "408",
                "429",
                "500",
                "502",
                "503",
                "504",
            };

            Func<Task<HttpResponseMessage>> retrySend = async () =>
            {
                var _httpRequest = await SDKConfiguration.Client.CloneAsync(httpRequest);
                return await SDKConfiguration.Client.SendAsync(_httpRequest, cancellationToken);
            };
            var retries = new Fastpix.Utils.Retries.Retries(retrySend, retryConfig, statusCodes);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await retries.Run();
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ListErrorsResponseBody obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<ListErrorsResponseBody>(httpResponseBody, NullValueHandling.Include);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ListErrorsResponseBody.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new ListErrorsResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.Object = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    DefaultError obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<DefaultError>(httpResponseBody, NullValueHandling.Include);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into DefaultError.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new ListErrorsResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.DefaultError = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
        }
    }
}