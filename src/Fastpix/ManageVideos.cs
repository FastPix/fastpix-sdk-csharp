//------------------------------------------------------------------------------
// <auto-generated>
// This code was generated by FastPix (https://FastPix.com). DO NOT EDIT.
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
namespace Fastpix
{
    using Fastpix.Hooks;
    using Fastpix.Models.Components;
    using Fastpix.Models.Errors;
    using Fastpix.Models.Requests;
    using Fastpix.Utils;
    using Fastpix.Utils.Retries;
    using Newtonsoft.Json;
    using System;
    using System.Collections.Generic;
    using System.Net.Http;
    using System.Net.Http.Headers;
    using System.Threading;
    using System.Threading.Tasks;

    public interface IManageVideos
    {

        /// <summary>
        /// Get all clips of a live stream
        /// 
        /// <remarks>
        /// Retrieves a list of all media clips generated from a specific livestream. Each media entry includes metadata such as the clip media IDs, and other relevant details. A media clip is a segmented portion of an original media file (source live stream). Clips are often created for various purposes such as previews, highlights, or customized edits.<br/>
        /// #### How it works<br/>
        /// To use this endpoint, provide the `livestreamId` as a parameter. The API then returns a paginated list of clipped media items created from that livestream. Pagination ensures optimal performance and usability when dealing with a large number of media files, making it easier to organize and manage content in bulk.<br/>
        /// <br/>
        /// Related guide: &lt;a href=&quot;https://docs.fastpix.io/docs/instant-live-clipping&quot;&gt;Instant live clipping&lt;/a&gt;<br/>
        /// 
        /// </remarks>
        /// </summary>
        Task<ListLiveClipsResponse> ListLiveClipsAsync(string livestreamId, long? limit = 10, long? offset = 1, SortOrder? orderBy = Fastpix.Models.Components.SortOrder.Desc, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null);

        /// <summary>
        /// Delete a media by ID
        /// 
        /// <remarks>
        /// This endpoint allows you to permanently delete a a specific video or audio media file along with all associated data. If you wish to remove a media from FastPix storage, use this endpoint with the `mediaId` (either `uploadId` or `id`) received during the media&apos;s creation or upload. <br/>
        /// <br/>
        /// <br/>
        /// #### How it works<br/>
        /// <br/>
        /// <br/>
        /// 1. Make a DELETE request to this endpoint, replacing `&lt;mediaId&gt;` with the `uploadId` or the `id` of the media you want to delete. <br/>
        /// <br/>
        /// 2. Since this action is irreversible, ensure that you no longer need the media before proceeding. Once deleted, the media cannot be retrieved or played back. <br/>
        /// <br/>
        /// 3. Webhook event to look for: &lt;a href=&quot;https://docs.fastpix.io/docs/media-events#videomediadeleted&quot;&gt;video.media.deleted&lt;/a&gt;<br/>
        /// <br/>
        /// #### Example<br/>
        /// A user on a video-sharing platform decides to remove an old video from their profile, or suppose you&apos;re running a content moderation system, and one of the videos uploaded by a user violates your platform&apos;s policies. Using this endpoint, the media is permanently deleted from your library, ensuring it&apos;s no longer accessible or viewable by other users.<br/>
        /// 
        /// </remarks>
        /// </summary>
        Task<DeleteMediaResponse> DeleteAsync(string mediaId, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null);

        /// <summary>
        /// Cancel ongoing upload
        /// 
        /// <remarks>
        /// This endpoint allows you to cancel ongoing upload by its `uploadId`. Once cancelled, the upload will be marked as cancelled. Use this if a user aborts an upload or if you want to programmatically stop an in-progress upload.<br/>
        /// <br/>
        /// #### How it works<br/>
        /// <br/>
        /// 1. Make a PUT request to this endpoint, replacing `{uploadId}` with the unique upload ID received after starting the upload.<br/>
        /// 2. The response will confirm the cancellation and provide the status of the upload.<br/>
        /// <br/>
        /// #### Webhook Events<br/>
        /// <br/>
        /// Once the upload is cancelled, you will receive the webhook event &lt;a href=&quot;https://docs.fastpix.io/docs/media-events#videomediauploadcancelled-event&quot;&gt;video.media.upload.cancelled&lt;/a&gt;.<br/>
        /// <br/>
        /// #### Example<br/>
        /// <br/>
        /// Suppose a user starts uploading a large video file but decides to cancel before completion. By calling this API, you can immediately stop the upload and free up resources.<br/>
        /// 
        /// </remarks>
        /// </summary>
        Task<CancelUploadResponse> CancelUploadAsync(string uploadId, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null);

        /// <summary>
        /// Update audio / subtitle track
        /// 
        /// <remarks>
        /// This endpoint allows you to update an existing audio or subtitle track associated with a media file. When updating a track, you must provide the new track `url`, `languageName`, and `languageCode`, ensuring all three parameters are included in the request.<br/>
        /// <br/>
        /// <br/>
        /// #### How it works<br/>
        /// <br/>
        /// 1. Send a PATCH request to this endpoint, replacing `{mediaId}` with the media ID, and `{trackId}` with the ID of the track you want to update.<br/>
        /// <br/>
        /// 2. Provide the necessary details in the request body.<br/>
        /// <br/>
        /// 3. Receive a response confirming the track update.<br/>
        /// <br/>
        /// #### Webhook Events<br/>
        /// <br/>
        /// After updating a track, your system will receive webhook notifications:<br/>
        /// <br/>
        /// 1. After successfully updating a track, your system will receive the webhook event &lt;a href=&quot;https://docs.fastpix.io/docs/transform-media-events#videomediatrackupdated&quot;&gt;video.media.track.updated&lt;/a&gt;.<br/>
        /// <br/>
        /// 2. Once the new track is processed and ready, you will receive the webhook event &lt;a href=&quot;https://docs.fastpix.io/docs/transform-media-events#videomediatrackready&quot;&gt;video.media.track.ready&lt;/a&gt;.<br/>
        /// <br/>
        /// 3. Once the media file is updated with the new track details, a &lt;a href=&quot;https://docs.fastpix.io/docs/media-events#videomediaupdated&quot;&gt;video.media.updated&lt;/a&gt; event will be triggered.<br/>
        /// <br/>
        /// <br/>
        /// #### Example<br/>
        /// Suppose you previously added a French subtitle track to a video but now need to update it with a different file. By calling this API, you can replace the existing subtitle file (.vtt) with a new one while keeping the same track ID. This is useful when:<br/>
        /// <br/>
        ///   - The original track file has errors and needs correction.<br/>
        ///   - You want to improve subtitle translations or replace an audio track with a better-quality version.<br/>
        ///   <br/>
        /// Related guides: &lt;a href=&quot;https://docs.fastpix.io/docs/manage-subtitle-tracks&quot;&gt;Add own subtitle tracks&lt;/a&gt;, &lt;a href=&quot;https://docs.fastpix.io/docs/manage-audio-tracks&quot;&gt;Add own audio tracks&lt;/a&gt;<br/>
        /// 
        /// </remarks>
        /// </summary>
        Task<UpdateMediaTrackResponse> UpdateTrackAsync(string trackId, string mediaId, UpdateTrackRequest updateTrackRequest, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null);

        /// <summary>
        /// Delete audio / subtitle track
        /// 
        /// <remarks>
        /// This endpoint allows you to delete an existing audio or subtitle track from a media file. Once deleted, the track will no longer be available for playback.<br/>
        /// <br/>
        /// <br/>
        /// #### How it works<br/>
        /// <br/>
        /// <br/>
        /// 1. Send a DELETE request to this endpoint, replacing `{mediaId}` with the media ID, and `{trackId}` with the ID of the track you want to remove.<br/>
        /// <br/>
        /// 2. The track will be deleted from the media file, and you will receive a confirmation response.<br/>
        /// <br/>
        /// #### Webhook events<br/>
        /// <br/>
        /// 1. After successfully deleting a track, your system will receive the webhook event **video.media.track.deleted**.<br/>
        /// <br/>
        /// 2. Once the media file is updated to reflect the track removal, a &lt;a href=&quot;https://docs.fastpix.io/docs/media-events#videomediaupdated&quot;&gt;video.media.updated&lt;/a&gt; event will be triggered.<br/>
        /// <br/>
        /// <br/>
        /// #### Example<br/>
        /// Suppose you uploaded an audio track in Italian for a video but later realize it&apos;s incorrect or no longer needed. By calling this API, you can remove the specific track while keeping the rest of the media file unchanged. This is useful when:<br/>
        /// <br/>
        ///   - A track was mistakenly added and needs to be removed.<br/>
        ///   - The content owner requests the removal of a specific subtitle or audio track.<br/>
        ///   - A new version of the track will be uploaded to replace the existing one.<br/>
        ///   <br/>
        /// Related guides: &lt;a href=&quot;https://docs.fastpix.io/docs/manage-subtitle-tracks&quot;&gt;Add own subtitle tracks&lt;/a&gt;, &lt;a href=&quot;https://docs.fastpix.io/docs/manage-audio-tracks&quot;&gt;Add own audio tracks&lt;/a&gt;<br/>
        /// 
        /// </remarks>
        /// </summary>
        Task<DeleteMediaTrackResponse> DeleteTrackAsync(string mediaId, string trackId, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null);

        /// <summary>
        /// Generate track subtitle
        /// 
        /// <remarks>
        /// This endpoint allows you to generate subtitles for an existing audio track in a media file. By calling this API, you can generate subtitles automatically using speech recognition<br/>
        /// <br/>
        /// #### How it works<br/>
        /// <br/>
        /// 1. Send a `POST` request to this endpoint, replacing `{mediaId}` with the media ID and `{trackId}` with the track ID.<br/>
        /// <br/>
        /// 2. Provide the necessary details in the request body, including the languageName and languageCode.<br/>
        /// <br/>
        /// 3. Receive a response containing a unique subtitle track ID and its details.<br/>
        /// <br/>
        /// #### Webhook Events<br/>
        /// <br/>
        /// 1. Once the subtitle track is generated and ready, you will receive the webhook event &lt;a href=&quot;https://docs.fastpix.io/docs/transform-media-events#videomediasubtitlegeneratedready&quot;&gt;video.media.subtitle.generated.ready&lt;/a&gt;.<br/>
        /// <br/>
        /// 2. Finally, an update event &lt;a href=&quot;https://docs.fastpix.io/docs/media-events#videomediaupdated&quot;&gt;video.media.updated&lt;/a&gt; will notify your system about the media&apos;s updated status.<br/>
        /// <br/>
        /// &lt;/br&gt; Related guide: &lt;a href=&quot;https://docs.fastpix.io/docs/add-auto-generated-subtitles-to-videos&quot;&gt;Add auto-generated subtitles&lt;/a&gt;<br/>
        /// 
        /// </remarks>
        /// </summary>
        Task<GenerateSubtitleTrackResponse> GenerateSubtitlesAsync(string mediaId, string trackId, TrackSubtitlesGenerateRequest trackSubtitlesGenerateRequest, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null);

        /// <summary>
        /// Update the source access of a media by ID
        /// 
        /// <remarks>
        /// This endpoint allows you to update the `sourceAccess` setting of an existing media file. The `sourceAccess` parameter determines whether the original media file is accessible or restricted. Setting this to `true` enables access to the media source, while setting it to `false` restricts access. <br/>
        /// <br/>
        /// #### How it works<br/>
        /// <br/>
        /// 1. Make a `PATCH` request to this endpoint, replacing `{mediaId}` with the ID of the media you want to update.<br/>
        /// <br/>
        /// 2. Include the updated `sourceAccess` parameter in the request body.<br/>
        /// <br/>
        /// 3. Receive a response confirming the update to the media&apos;s source access status.<br/>
        /// 4. Webhook events: &lt;a href=&quot;https://docs.fastpix.io/docs/transform-media-events#videomediasourceready&quot;&gt;video.media.source.ready&lt;/a&gt;, &lt;a href=&quot;https://docs.fastpix.io/docs/transform-media-events#videomediasourcedeleted&quot;&gt;video.media.source.deleted&lt;/a&gt;<br/>
        /// 
        /// </remarks>
        /// </summary>
        Task<UpdatedSourceAccessResponse> UpdateSourceAccessAsync(string mediaId, UpdatedSourceAccessRequestBody requestBody, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null);

        /// <summary>
        /// Update the mp4Support of a media by ID
        /// 
        /// <remarks>
        /// This endpoint allows you to update the `mp4Support` setting of an existing media file using its media ID. You can specify the MP4 support level, such as `none`, `capped_4k`, `audioOnly`, or a combination of `audioOnly`, `capped_4k`, in the request payload.<br/>
        /// <br/>
        /// #### How it works<br/>
        /// <br/>
        /// 1. Send a PATCH request to this endpoint, replacing `{mediaId}` with the media ID.<br/>
        /// <br/>
        /// 2. Provide the desired `mp4Support` value in the request body.<br/>
        /// <br/>
        /// 3. Receive a response confirming the update, including the media&apos;s updated MP4 support status.<br/>
        /// <br/>
        /// #### MP4 Support Options<br/>
        /// <br/>
        /// - `none` – MP4 support is disabled for this media.<br/>
        /// <br/>
        /// - `capped_4k` – The media will have mp4 renditions up to 4K resolution.<br/>
        /// <br/>
        /// - `audioOnly` – The media will generate an m4a file containing only the audio track.<br/>
        /// <br/>
        /// - `audioOnly,capped_4k` – The media will have both an audio-only m4a file and mp4 renditions up to 4K resolution.<br/>
        /// <br/>
        /// #### Webhook events<br/>
        /// <br/>
        /// - &lt;a href=&quot;https://docs.fastpix.io/docs/transform-media-events#videomediamp4supportready&quot;&gt;video.media.mp4Support.ready&lt;/a&gt; – Triggered when the MP4 support setting is successfully updated.<br/>
        /// <br/>
        /// #### Example<br/>
        /// Suppose you have a video uploaded to the FastPix platform, and you want to allow users to download the video in MP4 format. By setting &quot;mp4Support&quot;: &quot;capped_4k&quot;, the system will generate an MP4 rendition of the video up to 4K resolution, making it available for download via the stream URL(`https://stream.fastpix.io/{playbackId}/{capped-4k.mp4 | audio.m4a}`).<br/>
        /// If you want users to stream only the audio from the media file, you can set &quot;mp4Support&quot;: &quot;audioOnly&quot;. This will provide an audio-only stream URL that allows users to listen to the media without video.<br/>
        /// By setting &quot;mp4Support&quot;: &quot;audioOnly,capped_4k&quot;, both options will be enabled. Users will be able to download the MP4 video and also stream just the audio version of the media.<br/>
        /// <br/>
        /// <br/>
        /// Related guide: &lt;a href=&quot;https://docs.fastpix.io/docs/mp4-support-for-offline-viewing&quot;&gt;Use MP4 support for offline viewing&lt;/a&gt;<br/>
        /// 
        /// </remarks>
        /// </summary>
        Task<UpdatedMp4SupportResponse> UpdateMp4SupportAsync(string mediaId, UpdatedMp4SupportRequestBody requestBody, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null);

        /// <summary>
        /// Get info of media inputs
        /// 
        /// <remarks>
        /// Allows you to retrieve detailed information about the media inputs associated with a specific media item. You can use this endpoint to verify the media file&apos;s input URL, track creation status, and container format. The `mediaId` (either `uploadId` or `id`) must be provided to fetch the information. <br/>
        /// <br/>
        /// <br/>
        /// #### How it works<br/>
        /// <br/>
        /// Upon making a `GET` request with the mediaId, FastPix returns a response with: <br/>
        /// <br/>
        /// * The public storage input `url` of the uploaded media file. <br/>
        /// <br/>
        /// * Information about the `tracks` associated with the media, including both video and audio tracks, indicating whether they have been successfully created. <br/>
        /// <br/>
        /// * The format of the uploaded media file container (e.g., MP4, MKV). <br/>
        /// <br/>
        /// This endpoint is particularly useful for ensuring that all necessary tracks (video and audio) have been correctly associated with the media during the upload or media creation process.<br/>
        /// 
        /// </remarks>
        /// </summary>
        Task<RetrieveMediaInputInfoResponse> GetInputInfoAsync(string mediaId, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null);

        /// <summary>
        /// Get all clips of a media
        /// 
        /// <remarks>
        /// This endpoint retrieves a list of all media clips associated with a given source media ID. It helps in organizing and managing media&apos;s efficiently by providing metadata, including clip media IDs and other relevant details.<br/>
        /// <br/>
        /// A media clip is a segmented portion of an original media file (source media). Clips are often created for various purposes such as previews, highlights, or customized edits. This API allows you to fetch all such clips linked to a specific source media, making it easier to track and manage clips.<br/>
        /// <br/>
        /// <br/>
        /// #### How it works<br/>
        /// <br/>
        /// - The endpoint returns metadata for all media clips associated with the given `sourceMediaId`.<br/>
        /// - Results are paginated to efficiently handle large datasets.<br/>
        /// - Each entry includes detailed metadata such as media `id`, `duration`, and `status`.<br/>
        /// - Helps in organizing clips effectively by providing structured information.<br/>
        /// <br/>
        /// <br/>
        /// #### Example<br/>
        /// <br/>
        /// Imagine you&apos;re managing a video editing platform where users upload full-length videos and create short clips for social media sharing. To keep track of all clips linked to a particular video, you call this API with the sourceMediaId. The response provides a list of all associated clips, allowing you to manage, edit, or repurpose them as needed.<br/>
        /// <br/>
        /// Related guide: &lt;a href=&quot;https://docs.fastpix.io/docs/create-clips-from-existing-media&quot;&gt;Create clips from existing media&lt;/a&gt;<br/>
        /// 
        /// </remarks>
        /// </summary>
        Task<GetMediaClipsResponse> ListMediaClipsAsync(string sourceMediaId, long? offset = 1, long? limit = 10, SortOrder? orderBy = Fastpix.Models.Components.SortOrder.Desc, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null);
    }

    public class ManageVideos: IManageVideos
    {
        public SDKConfig SDKConfiguration { get; private set; }
        private const string _language = "csharp";
        private const string _sdkVersion = "1.0.0";
        private const string _sdkGenVersion = "2.721.3";
        private const string _openapiDocVersion = "1.0.0";

        public ManageVideos(SDKConfig config)
        {
            SDKConfiguration = config;
        }

        public async Task<ListLiveClipsResponse> ListLiveClipsAsync(string livestreamId, long? limit = 10, long? offset = 1, SortOrder? orderBy = Fastpix.Models.Components.SortOrder.Desc, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null)
        {
            var request = new ListLiveClipsRequest()
            {
                LivestreamId = livestreamId,
                Limit = limit,
                Offset = offset,
                OrderBy = orderBy,
            };
            string baseUrl = this.SDKConfiguration.GetTemplatedServerUrl();
            var urlString = URLBuilder.Build(baseUrl, "/on-demand/{livestreamId}/live-clips", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Get, urlString);
            httpRequest.Headers.Add("user-agent", SDKConfiguration.UserAgent);

            if (SDKConfiguration.SecuritySource != null)
            {
                httpRequest = new SecurityMetadata(SDKConfiguration.SecuritySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext(SDKConfiguration, baseUrl, "list-live-clips", new List<string> {  }, SDKConfiguration.SecuritySource, cancellationToken);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);
            if (retryConfig == null)
            {
                if (this.SDKConfiguration.RetryConfig != null)
                {
                    retryConfig = this.SDKConfiguration.RetryConfig;
                }
                else
                {
                    var backoff = new BackoffStrategy(
                        initialIntervalMs: 1000L,
                        maxIntervalMs: 10000L,
                        maxElapsedTimeMs: 3600000L,
                        exponent: 1.5
                    );
                    retryConfig = new RetryConfig(
                        strategy: RetryConfig.RetryStrategy.BACKOFF,
                        backoff: backoff,
                        retryConnectionErrors: true
                    );
                }
            }

            List<string> statusCodes = new List<string>
            {
                "408",
                "429",
                "500",
                "502",
                "503",
                "504",
            };

            Func<Task<HttpResponseMessage>> retrySend = async () =>
            {
                var _httpRequest = await SDKConfiguration.Client.CloneAsync(httpRequest);
                return await SDKConfiguration.Client.SendAsync(_httpRequest, cancellationToken);
            };
            var retries = new Fastpix.Utils.Retries.Retries(retrySend, retryConfig, statusCodes);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await retries.Run();
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode == 401 || _statusCode == 403 || _statusCode == 422 || _statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ListLiveClipsResponseBody obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<ListLiveClipsResponseBody>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ListLiveClipsResponseBody.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new ListLiveClipsResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.Object = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 401)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    InvalidPermissionExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<InvalidPermissionExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into InvalidPermissionExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new InvalidPermissionException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 403)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ForbiddenExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<ForbiddenExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ForbiddenExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new ForbiddenException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 422)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ValidationErrorResponsePayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<ValidationErrorResponsePayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ValidationErrorResponsePayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new ValidationErrorResponse(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }

            throw new Models.Errors.APIException("Unknown status code received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
        }

        public async Task<DeleteMediaResponse> DeleteAsync(string mediaId, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null)
        {
            var request = new DeleteMediaRequest()
            {
                MediaId = mediaId,
            };
            string baseUrl = this.SDKConfiguration.GetTemplatedServerUrl();
            var urlString = URLBuilder.Build(baseUrl, "/on-demand/{mediaId}", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Delete, urlString);
            httpRequest.Headers.Add("user-agent", SDKConfiguration.UserAgent);

            if (SDKConfiguration.SecuritySource != null)
            {
                httpRequest = new SecurityMetadata(SDKConfiguration.SecuritySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext(SDKConfiguration, baseUrl, "delete-media", new List<string> {  }, SDKConfiguration.SecuritySource, cancellationToken);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);
            if (retryConfig == null)
            {
                if (this.SDKConfiguration.RetryConfig != null)
                {
                    retryConfig = this.SDKConfiguration.RetryConfig;
                }
                else
                {
                    var backoff = new BackoffStrategy(
                        initialIntervalMs: 1000L,
                        maxIntervalMs: 10000L,
                        maxElapsedTimeMs: 3600000L,
                        exponent: 1.5
                    );
                    retryConfig = new RetryConfig(
                        strategy: RetryConfig.RetryStrategy.BACKOFF,
                        backoff: backoff,
                        retryConnectionErrors: true
                    );
                }
            }

            List<string> statusCodes = new List<string>
            {
                "408",
                "429",
                "500",
                "502",
                "503",
                "504",
            };

            Func<Task<HttpResponseMessage>> retrySend = async () =>
            {
                var _httpRequest = await SDKConfiguration.Client.CloneAsync(httpRequest);
                return await SDKConfiguration.Client.SendAsync(_httpRequest, cancellationToken);
            };
            var retries = new Fastpix.Utils.Retries.Retries(retrySend, retryConfig, statusCodes);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await retries.Run();
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode == 401 || _statusCode == 403 || _statusCode == 404 || _statusCode == 422 || _statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    DeleteMediaResponseBody obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<DeleteMediaResponseBody>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into DeleteMediaResponseBody.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new DeleteMediaResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.Object = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 401)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    InvalidPermissionExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<InvalidPermissionExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into InvalidPermissionExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new InvalidPermissionException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 403)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ForbiddenExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<ForbiddenExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ForbiddenExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new ForbiddenException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 404)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    MediaNotFoundExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<MediaNotFoundExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into MediaNotFoundExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new MediaNotFoundException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 422)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ValidationErrorResponsePayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<ValidationErrorResponsePayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ValidationErrorResponsePayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new ValidationErrorResponse(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }

            throw new Models.Errors.APIException("Unknown status code received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
        }

        public async Task<CancelUploadResponse> CancelUploadAsync(string uploadId, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null)
        {
            var request = new CancelUploadRequest()
            {
                UploadId = uploadId,
            };
            string baseUrl = this.SDKConfiguration.GetTemplatedServerUrl();
            var urlString = URLBuilder.Build(baseUrl, "/on-demand/upload/{uploadId}/cancel", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Put, urlString);
            httpRequest.Headers.Add("user-agent", SDKConfiguration.UserAgent);

            if (SDKConfiguration.SecuritySource != null)
            {
                httpRequest = new SecurityMetadata(SDKConfiguration.SecuritySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext(SDKConfiguration, baseUrl, "cancel-upload", new List<string> {  }, SDKConfiguration.SecuritySource, cancellationToken);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);
            if (retryConfig == null)
            {
                if (this.SDKConfiguration.RetryConfig != null)
                {
                    retryConfig = this.SDKConfiguration.RetryConfig;
                }
                else
                {
                    var backoff = new BackoffStrategy(
                        initialIntervalMs: 1000L,
                        maxIntervalMs: 10000L,
                        maxElapsedTimeMs: 3600000L,
                        exponent: 1.5
                    );
                    retryConfig = new RetryConfig(
                        strategy: RetryConfig.RetryStrategy.BACKOFF,
                        backoff: backoff,
                        retryConnectionErrors: true
                    );
                }
            }

            List<string> statusCodes = new List<string>
            {
                "408",
                "429",
                "500",
                "502",
                "503",
                "504",
            };

            Func<Task<HttpResponseMessage>> retrySend = async () =>
            {
                var _httpRequest = await SDKConfiguration.Client.CloneAsync(httpRequest);
                return await SDKConfiguration.Client.SendAsync(_httpRequest, cancellationToken);
            };
            var retries = new Fastpix.Utils.Retries.Retries(retrySend, retryConfig, statusCodes);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await retries.Run();
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode == 400 || _statusCode == 401 || _statusCode == 403 || _statusCode == 404 || _statusCode == 422 || _statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    CancelUploadResponseBody obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<CancelUploadResponseBody>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into CancelUploadResponseBody.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new CancelUploadResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.Object = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 400)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    BadRequestExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<BadRequestExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into BadRequestExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new BadRequestException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 401)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    InvalidPermissionExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<InvalidPermissionExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into InvalidPermissionExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new InvalidPermissionException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 403)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ForbiddenExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<ForbiddenExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ForbiddenExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new ForbiddenException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 404)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    MediaNotFoundExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<MediaNotFoundExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into MediaNotFoundExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new MediaNotFoundException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 422)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ValidationErrorResponsePayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<ValidationErrorResponsePayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ValidationErrorResponsePayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new ValidationErrorResponse(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }

            throw new Models.Errors.APIException("Unknown status code received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
        }

        public async Task<UpdateMediaTrackResponse> UpdateTrackAsync(string trackId, string mediaId, UpdateTrackRequest updateTrackRequest, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null)
        {
            var request = new UpdateMediaTrackRequest()
            {
                TrackId = trackId,
                MediaId = mediaId,
                UpdateTrackRequest = updateTrackRequest,
            };
            string baseUrl = this.SDKConfiguration.GetTemplatedServerUrl();
            var urlString = URLBuilder.Build(baseUrl, "/on-demand/{mediaId}/tracks/{trackId}", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Patch, urlString);
            httpRequest.Headers.Add("user-agent", SDKConfiguration.UserAgent);

            var serializedBody = RequestBodySerializer.Serialize(request, "UpdateTrackRequest", "json", false, false);
            if (serializedBody != null)
            {
                httpRequest.Content = serializedBody;
            }

            if (SDKConfiguration.SecuritySource != null)
            {
                httpRequest = new SecurityMetadata(SDKConfiguration.SecuritySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext(SDKConfiguration, baseUrl, "update-media-track", new List<string> {  }, SDKConfiguration.SecuritySource, cancellationToken);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);
            if (retryConfig == null)
            {
                if (this.SDKConfiguration.RetryConfig != null)
                {
                    retryConfig = this.SDKConfiguration.RetryConfig;
                }
                else
                {
                    var backoff = new BackoffStrategy(
                        initialIntervalMs: 1000L,
                        maxIntervalMs: 10000L,
                        maxElapsedTimeMs: 3600000L,
                        exponent: 1.5
                    );
                    retryConfig = new RetryConfig(
                        strategy: RetryConfig.RetryStrategy.BACKOFF,
                        backoff: backoff,
                        retryConnectionErrors: true
                    );
                }
            }

            List<string> statusCodes = new List<string>
            {
                "408",
                "429",
                "500",
                "502",
                "503",
                "504",
            };

            Func<Task<HttpResponseMessage>> retrySend = async () =>
            {
                var _httpRequest = await SDKConfiguration.Client.CloneAsync(httpRequest);
                return await SDKConfiguration.Client.SendAsync(_httpRequest, cancellationToken);
            };
            var retries = new Fastpix.Utils.Retries.Retries(retrySend, retryConfig, statusCodes);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await retries.Run();
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode == 400 || _statusCode == 401 || _statusCode == 403 || _statusCode == 404 || _statusCode == 422 || _statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    UpdateMediaTrackResponseBody obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<UpdateMediaTrackResponseBody>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into UpdateMediaTrackResponseBody.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new UpdateMediaTrackResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.Object = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 400)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    TrackDuplicateRequestExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<TrackDuplicateRequestExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into TrackDuplicateRequestExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new TrackDuplicateRequestException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 401)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    InvalidPermissionExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<InvalidPermissionExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into InvalidPermissionExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new InvalidPermissionException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 403)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ForbiddenExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<ForbiddenExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ForbiddenExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new ForbiddenException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 404)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    MediaNotFoundExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<MediaNotFoundExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into MediaNotFoundExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new MediaNotFoundException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 422)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ValidationErrorResponsePayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<ValidationErrorResponsePayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ValidationErrorResponsePayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new ValidationErrorResponse(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }

            throw new Models.Errors.APIException("Unknown status code received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
        }

        public async Task<DeleteMediaTrackResponse> DeleteTrackAsync(string mediaId, string trackId, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null)
        {
            var request = new DeleteMediaTrackRequest()
            {
                MediaId = mediaId,
                TrackId = trackId,
            };
            string baseUrl = this.SDKConfiguration.GetTemplatedServerUrl();
            var urlString = URLBuilder.Build(baseUrl, "/on-demand/{mediaId}/tracks/{trackId}", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Delete, urlString);
            httpRequest.Headers.Add("user-agent", SDKConfiguration.UserAgent);

            if (SDKConfiguration.SecuritySource != null)
            {
                httpRequest = new SecurityMetadata(SDKConfiguration.SecuritySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext(SDKConfiguration, baseUrl, "delete-media-track", new List<string> {  }, SDKConfiguration.SecuritySource, cancellationToken);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);
            if (retryConfig == null)
            {
                if (this.SDKConfiguration.RetryConfig != null)
                {
                    retryConfig = this.SDKConfiguration.RetryConfig;
                }
                else
                {
                    var backoff = new BackoffStrategy(
                        initialIntervalMs: 1000L,
                        maxIntervalMs: 10000L,
                        maxElapsedTimeMs: 3600000L,
                        exponent: 1.5
                    );
                    retryConfig = new RetryConfig(
                        strategy: RetryConfig.RetryStrategy.BACKOFF,
                        backoff: backoff,
                        retryConnectionErrors: true
                    );
                }
            }

            List<string> statusCodes = new List<string>
            {
                "408",
                "429",
                "500",
                "502",
                "503",
                "504",
            };

            Func<Task<HttpResponseMessage>> retrySend = async () =>
            {
                var _httpRequest = await SDKConfiguration.Client.CloneAsync(httpRequest);
                return await SDKConfiguration.Client.SendAsync(_httpRequest, cancellationToken);
            };
            var retries = new Fastpix.Utils.Retries.Retries(retrySend, retryConfig, statusCodes);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await retries.Run();
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode == 401 || _statusCode == 403 || _statusCode == 404 || _statusCode == 422 || _statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    DeleteMediaTrackResponseBody obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<DeleteMediaTrackResponseBody>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into DeleteMediaTrackResponseBody.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new DeleteMediaTrackResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.Object = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 401)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    InvalidPermissionExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<InvalidPermissionExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into InvalidPermissionExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new InvalidPermissionException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 403)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ForbiddenExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<ForbiddenExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ForbiddenExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new ForbiddenException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 404)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    MediaNotFoundExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<MediaNotFoundExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into MediaNotFoundExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new MediaNotFoundException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 422)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ValidationErrorResponsePayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<ValidationErrorResponsePayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ValidationErrorResponsePayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new ValidationErrorResponse(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }

            throw new Models.Errors.APIException("Unknown status code received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
        }

        public async Task<GenerateSubtitleTrackResponse> GenerateSubtitlesAsync(string mediaId, string trackId, TrackSubtitlesGenerateRequest trackSubtitlesGenerateRequest, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null)
        {
            var request = new GenerateSubtitleTrackRequest()
            {
                MediaId = mediaId,
                TrackId = trackId,
                TrackSubtitlesGenerateRequest = trackSubtitlesGenerateRequest,
            };
            string baseUrl = this.SDKConfiguration.GetTemplatedServerUrl();
            var urlString = URLBuilder.Build(baseUrl, "/on-demand/{mediaId}/tracks/{trackId}/generate-subtitles", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Post, urlString);
            httpRequest.Headers.Add("user-agent", SDKConfiguration.UserAgent);

            var serializedBody = RequestBodySerializer.Serialize(request, "TrackSubtitlesGenerateRequest", "json", false, false);
            if (serializedBody != null)
            {
                httpRequest.Content = serializedBody;
            }

            if (SDKConfiguration.SecuritySource != null)
            {
                httpRequest = new SecurityMetadata(SDKConfiguration.SecuritySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext(SDKConfiguration, baseUrl, "Generate-subtitle-track", new List<string> {  }, SDKConfiguration.SecuritySource, cancellationToken);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);
            if (retryConfig == null)
            {
                if (this.SDKConfiguration.RetryConfig != null)
                {
                    retryConfig = this.SDKConfiguration.RetryConfig;
                }
                else
                {
                    var backoff = new BackoffStrategy(
                        initialIntervalMs: 1000L,
                        maxIntervalMs: 10000L,
                        maxElapsedTimeMs: 3600000L,
                        exponent: 1.5
                    );
                    retryConfig = new RetryConfig(
                        strategy: RetryConfig.RetryStrategy.BACKOFF,
                        backoff: backoff,
                        retryConnectionErrors: true
                    );
                }
            }

            List<string> statusCodes = new List<string>
            {
                "408",
                "429",
                "500",
                "502",
                "503",
                "504",
            };

            Func<Task<HttpResponseMessage>> retrySend = async () =>
            {
                var _httpRequest = await SDKConfiguration.Client.CloneAsync(httpRequest);
                return await SDKConfiguration.Client.SendAsync(_httpRequest, cancellationToken);
            };
            var retries = new Fastpix.Utils.Retries.Retries(retrySend, retryConfig, statusCodes);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await retries.Run();
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode == 400 || _statusCode == 401 || _statusCode == 403 || _statusCode == 404 || _statusCode == 422 || _statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    GenerateSubtitleTrackResponseBody obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<GenerateSubtitleTrackResponseBody>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into GenerateSubtitleTrackResponseBody.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new GenerateSubtitleTrackResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.Object = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 400)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    TrackDuplicateRequestExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<TrackDuplicateRequestExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into TrackDuplicateRequestExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new TrackDuplicateRequestException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 401)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    InvalidPermissionExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<InvalidPermissionExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into InvalidPermissionExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new InvalidPermissionException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 403)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ForbiddenExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<ForbiddenExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ForbiddenExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new ForbiddenException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 404)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    MediaNotFoundExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<MediaNotFoundExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into MediaNotFoundExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new MediaNotFoundException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 422)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ValidationErrorResponsePayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<ValidationErrorResponsePayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ValidationErrorResponsePayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new ValidationErrorResponse(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }

            throw new Models.Errors.APIException("Unknown status code received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
        }

        public async Task<UpdatedSourceAccessResponse> UpdateSourceAccessAsync(string mediaId, UpdatedSourceAccessRequestBody requestBody, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null)
        {
            var request = new UpdatedSourceAccessRequest()
            {
                MediaId = mediaId,
                RequestBody = requestBody,
            };
            string baseUrl = this.SDKConfiguration.GetTemplatedServerUrl();
            var urlString = URLBuilder.Build(baseUrl, "/on-demand/{mediaId}/source-access", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Patch, urlString);
            httpRequest.Headers.Add("user-agent", SDKConfiguration.UserAgent);

            var serializedBody = RequestBodySerializer.Serialize(request, "RequestBody", "json", false, false);
            if (serializedBody != null)
            {
                httpRequest.Content = serializedBody;
            }

            if (SDKConfiguration.SecuritySource != null)
            {
                httpRequest = new SecurityMetadata(SDKConfiguration.SecuritySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext(SDKConfiguration, baseUrl, "updated-source-access", new List<string> {  }, SDKConfiguration.SecuritySource, cancellationToken);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);
            if (retryConfig == null)
            {
                if (this.SDKConfiguration.RetryConfig != null)
                {
                    retryConfig = this.SDKConfiguration.RetryConfig;
                }
                else
                {
                    var backoff = new BackoffStrategy(
                        initialIntervalMs: 1000L,
                        maxIntervalMs: 10000L,
                        maxElapsedTimeMs: 3600000L,
                        exponent: 1.5
                    );
                    retryConfig = new RetryConfig(
                        strategy: RetryConfig.RetryStrategy.BACKOFF,
                        backoff: backoff,
                        retryConnectionErrors: true
                    );
                }
            }

            List<string> statusCodes = new List<string>
            {
                "408",
                "429",
                "500",
                "502",
                "503",
                "504",
            };

            Func<Task<HttpResponseMessage>> retrySend = async () =>
            {
                var _httpRequest = await SDKConfiguration.Client.CloneAsync(httpRequest);
                return await SDKConfiguration.Client.SendAsync(_httpRequest, cancellationToken);
            };
            var retries = new Fastpix.Utils.Retries.Retries(retrySend, retryConfig, statusCodes);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await retries.Run();
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode == 401 || _statusCode == 403 || _statusCode == 404 || _statusCode == 422 || _statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    UpdatedSourceAccessResponseBody obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<UpdatedSourceAccessResponseBody>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into UpdatedSourceAccessResponseBody.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new UpdatedSourceAccessResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.Object = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 401)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    InvalidPermissionExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<InvalidPermissionExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into InvalidPermissionExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new InvalidPermissionException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 403)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ForbiddenExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<ForbiddenExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ForbiddenExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new ForbiddenException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 404)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    MediaNotFoundExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<MediaNotFoundExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into MediaNotFoundExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new MediaNotFoundException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 422)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ValidationErrorResponsePayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<ValidationErrorResponsePayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ValidationErrorResponsePayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new ValidationErrorResponse(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }

            throw new Models.Errors.APIException("Unknown status code received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
        }

        public async Task<UpdatedMp4SupportResponse> UpdateMp4SupportAsync(string mediaId, UpdatedMp4SupportRequestBody requestBody, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null)
        {
            var request = new UpdatedMp4SupportRequest()
            {
                MediaId = mediaId,
                RequestBody = requestBody,
            };
            string baseUrl = this.SDKConfiguration.GetTemplatedServerUrl();
            var urlString = URLBuilder.Build(baseUrl, "/on-demand/{mediaId}/update-mp4Support", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Patch, urlString);
            httpRequest.Headers.Add("user-agent", SDKConfiguration.UserAgent);

            var serializedBody = RequestBodySerializer.Serialize(request, "RequestBody", "json", false, false);
            if (serializedBody != null)
            {
                httpRequest.Content = serializedBody;
            }

            if (SDKConfiguration.SecuritySource != null)
            {
                httpRequest = new SecurityMetadata(SDKConfiguration.SecuritySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext(SDKConfiguration, baseUrl, "updated-mp4Support", new List<string> {  }, SDKConfiguration.SecuritySource, cancellationToken);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);
            if (retryConfig == null)
            {
                if (this.SDKConfiguration.RetryConfig != null)
                {
                    retryConfig = this.SDKConfiguration.RetryConfig;
                }
                else
                {
                    var backoff = new BackoffStrategy(
                        initialIntervalMs: 1000L,
                        maxIntervalMs: 10000L,
                        maxElapsedTimeMs: 3600000L,
                        exponent: 1.5
                    );
                    retryConfig = new RetryConfig(
                        strategy: RetryConfig.RetryStrategy.BACKOFF,
                        backoff: backoff,
                        retryConnectionErrors: true
                    );
                }
            }

            List<string> statusCodes = new List<string>
            {
                "408",
                "429",
                "500",
                "502",
                "503",
                "504",
            };

            Func<Task<HttpResponseMessage>> retrySend = async () =>
            {
                var _httpRequest = await SDKConfiguration.Client.CloneAsync(httpRequest);
                return await SDKConfiguration.Client.SendAsync(_httpRequest, cancellationToken);
            };
            var retries = new Fastpix.Utils.Retries.Retries(retrySend, retryConfig, statusCodes);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await retries.Run();
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode == 400 || _statusCode == 401 || _statusCode == 403 || _statusCode == 404 || _statusCode == 422 || _statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    UpdatedMp4SupportResponseBody obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<UpdatedMp4SupportResponseBody>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into UpdatedMp4SupportResponseBody.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new UpdatedMp4SupportResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.Object = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 400)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    DuplicateMp4SupportExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<DuplicateMp4SupportExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into DuplicateMp4SupportExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new DuplicateMp4SupportException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 401)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    InvalidPermissionExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<InvalidPermissionExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into InvalidPermissionExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new InvalidPermissionException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 403)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ForbiddenExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<ForbiddenExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ForbiddenExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new ForbiddenException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 404)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    MediaNotFoundExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<MediaNotFoundExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into MediaNotFoundExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new MediaNotFoundException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 422)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ValidationErrorResponsePayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<ValidationErrorResponsePayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ValidationErrorResponsePayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new ValidationErrorResponse(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }

            throw new Models.Errors.APIException("Unknown status code received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
        }

        public async Task<RetrieveMediaInputInfoResponse> GetInputInfoAsync(string mediaId, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null)
        {
            var request = new RetrieveMediaInputInfoRequest()
            {
                MediaId = mediaId,
            };
            string baseUrl = this.SDKConfiguration.GetTemplatedServerUrl();
            var urlString = URLBuilder.Build(baseUrl, "/on-demand/{mediaId}/input-info", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Get, urlString);
            httpRequest.Headers.Add("user-agent", SDKConfiguration.UserAgent);

            if (SDKConfiguration.SecuritySource != null)
            {
                httpRequest = new SecurityMetadata(SDKConfiguration.SecuritySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext(SDKConfiguration, baseUrl, "retrieveMediaInputInfo", new List<string> {  }, SDKConfiguration.SecuritySource, cancellationToken);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);
            if (retryConfig == null)
            {
                if (this.SDKConfiguration.RetryConfig != null)
                {
                    retryConfig = this.SDKConfiguration.RetryConfig;
                }
                else
                {
                    var backoff = new BackoffStrategy(
                        initialIntervalMs: 1000L,
                        maxIntervalMs: 10000L,
                        maxElapsedTimeMs: 3600000L,
                        exponent: 1.5
                    );
                    retryConfig = new RetryConfig(
                        strategy: RetryConfig.RetryStrategy.BACKOFF,
                        backoff: backoff,
                        retryConnectionErrors: true
                    );
                }
            }

            List<string> statusCodes = new List<string>
            {
                "408",
                "429",
                "500",
                "502",
                "503",
                "504",
            };

            Func<Task<HttpResponseMessage>> retrySend = async () =>
            {
                var _httpRequest = await SDKConfiguration.Client.CloneAsync(httpRequest);
                return await SDKConfiguration.Client.SendAsync(_httpRequest, cancellationToken);
            };
            var retries = new Fastpix.Utils.Retries.Retries(retrySend, retryConfig, statusCodes);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await retries.Run();
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode == 401 || _statusCode == 403 || _statusCode == 404 || _statusCode == 422 || _statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    RetrieveMediaInputInfoResponseBody obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<RetrieveMediaInputInfoResponseBody>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into RetrieveMediaInputInfoResponseBody.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new RetrieveMediaInputInfoResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.Object = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 401)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    InvalidPermissionExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<InvalidPermissionExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into InvalidPermissionExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new InvalidPermissionException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 403)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ForbiddenExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<ForbiddenExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ForbiddenExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new ForbiddenException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 404)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    MediaNotFoundExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<MediaNotFoundExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into MediaNotFoundExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new MediaNotFoundException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 422)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ValidationErrorResponsePayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<ValidationErrorResponsePayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ValidationErrorResponsePayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new ValidationErrorResponse(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }

            throw new Models.Errors.APIException("Unknown status code received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
        }

        public async Task<GetMediaClipsResponse> ListMediaClipsAsync(string sourceMediaId, long? offset = 1, long? limit = 10, SortOrder? orderBy = Fastpix.Models.Components.SortOrder.Desc, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null)
        {
            var request = new GetMediaClipsRequest()
            {
                SourceMediaId = sourceMediaId,
                Offset = offset,
                Limit = limit,
                OrderBy = orderBy,
            };
            string baseUrl = this.SDKConfiguration.GetTemplatedServerUrl();
            var urlString = URLBuilder.Build(baseUrl, "/on-demand/{sourceMediaId}/media-clips", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Get, urlString);
            httpRequest.Headers.Add("user-agent", SDKConfiguration.UserAgent);

            if (SDKConfiguration.SecuritySource != null)
            {
                httpRequest = new SecurityMetadata(SDKConfiguration.SecuritySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext(SDKConfiguration, baseUrl, "get-media-clips", new List<string> {  }, SDKConfiguration.SecuritySource, cancellationToken);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);
            if (retryConfig == null)
            {
                if (this.SDKConfiguration.RetryConfig != null)
                {
                    retryConfig = this.SDKConfiguration.RetryConfig;
                }
                else
                {
                    var backoff = new BackoffStrategy(
                        initialIntervalMs: 1000L,
                        maxIntervalMs: 10000L,
                        maxElapsedTimeMs: 3600000L,
                        exponent: 1.5
                    );
                    retryConfig = new RetryConfig(
                        strategy: RetryConfig.RetryStrategy.BACKOFF,
                        backoff: backoff,
                        retryConnectionErrors: true
                    );
                }
            }

            List<string> statusCodes = new List<string>
            {
                "408",
                "429",
                "500",
                "502",
                "503",
                "504",
            };

            Func<Task<HttpResponseMessage>> retrySend = async () =>
            {
                var _httpRequest = await SDKConfiguration.Client.CloneAsync(httpRequest);
                return await SDKConfiguration.Client.SendAsync(_httpRequest, cancellationToken);
            };
            var retries = new Fastpix.Utils.Retries.Retries(retrySend, retryConfig, statusCodes);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await retries.Run();
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode == 401 || _statusCode == 403 || _statusCode == 404 || _statusCode == 422 || _statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    MediaClipResponse obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<MediaClipResponse>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into MediaClipResponse.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new GetMediaClipsResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.MediaClipResponse = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 401)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    InvalidPermissionExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<InvalidPermissionExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into InvalidPermissionExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new InvalidPermissionException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 403)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ForbiddenExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<ForbiddenExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ForbiddenExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new ForbiddenException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 404)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    MediaClipNotFoundExceptionPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<MediaClipNotFoundExceptionPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into MediaClipNotFoundExceptionPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new MediaClipNotFoundException(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode == 422)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ValidationErrorResponsePayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<ValidationErrorResponsePayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ValidationErrorResponsePayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    payload.HttpMeta = new Models.Components.HTTPMetadata()
                    {
                        Response = httpResponse,
                        Request = httpRequest
                    };

                    throw new ValidationErrorResponse(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }

            throw new Models.Errors.APIException("Unknown status code received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
        }
    }
}