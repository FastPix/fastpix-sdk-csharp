/* 
 * This file is auto-generated.
 * Do not edit this file manually.
 * Your changes will be overwritten during the next generation.
 */
#nullable enable
namespace Fastpix
{
    using Fastpix.Hooks;
    using Fastpix.Models.Components;
    using Fastpix.Models.Errors;
    using Fastpix.Models.Requests;
    using Fastpix.Utils;
    using Fastpix.Utils.Retries;
    using Newtonsoft.Json;
    using System;
    using System.Collections.Generic;
    using System.Net.Http;
    using System.Net.Http.Headers;
    using System.Threading;
    using System.Threading.Tasks;

    public interface IInputVideo
    {

        /// <summary>
        /// Create media from URL
        /// 
        /// <remarks>
        /// This endpoint allows developers or users to create a new video or audio media in FastPix using a publicly accessible URL. FastPix fetches the media from the provided URL, processes it, and stores it on the platform for use.<br/>
        /// <br/>
        /// <br/>
        /// <br/>
        /// #### Public URL requirement:<br/>
        /// <br/>
        /// <br/>
        ///   The provided URL must be publicly accessible and must point to a video stored in one of the following supported formats: .m4v, .ogv, .mpeg, .mov, .3gp, .f4v, .rm, .ts, .wtv, .avi, .mp4, .wmv, .webm, .mts, .vob, .mxf, asf, m2ts <br/>
        /// <br/>
        /// <br/>
        /// <br/>
        /// #### Supported storage types:<br/>
        /// <br/>
        /// The URL can originate from various cloud storage services or content delivery networks (CDNs) such as: <br/>
        /// <br/>
        /// <br/>
        /// * **Amazon S3:** URLs from Amazon&apos;s Simple Storage Service. <br/>
        /// <br/>
        /// * **Google Cloud Storage:** URLs from Google Cloud&apos;s storage solution. <br/>
        /// <br/>
        /// * **Azure Blob Storage:** URLs from Microsoft&apos;s Azure storage. <br/>
        /// <br/>
        /// * **Public CDNs:** URLs from public content delivery networks that host video files. <br/>
        /// <br/>
        /// Upon successful creation, the API returns an `id` that must be retained for future operations related to this media. <br/>
        /// <br/>
        /// #### How it works<br/>
        /// <br/>
        /// <br/>
        /// 1. Send a POST request to this endpoint with the media URL (typically a video or audio file) and optional media settings. <br/>
        /// <br/>
        /// 2. FastPix uploads the video from the provided URL to its storage. <br/>
        /// <br/>
        /// 3. Receive a response containing the unique id for the newly created media item. <br/>
        /// <br/>
        /// 4. Use the id in subsequent API calls, such as checking the status of the media with the &lt;a href=&quot;https://docs.fastpix.io/reference/get-media&quot;&gt;Get Media by ID&lt;/a&gt; endpoint to determine when the media is ready for playback. <br/>
        /// <br/>
        /// FastPix uses webhooks to tell your application about things that happen in the background, outside of the API regular request flow. For instance, after the media file is created (but not yet processed or encoded), FastPix sends a `POST` request to your specified webhook URL with the event &lt;a href=&quot;https://docs.fastpix.io/docs/media-events#videomediacreated&quot;&gt;video.media.created&lt;/a&gt;. <br/>
        /// <br/>
        /// <br/>
        /// After processing completes, monitor the events &lt;a href=&quot;https://docs.fastpix.io/docs/media-events#videomediaready&quot;&gt;video.media.ready&lt;/a&gt; and &lt;a href=&quot;https://docs.fastpix.io/docs/media-events#videomediafailed&quot;&gt;video.media.failed&lt;/a&gt; to track the status of the media file.<br/>
        /// <br/>
        /// Related guide: &lt;a href=&quot;https://docs.fastpix.io/docs/upload-videos-from-url&quot;&gt;Upload videos from URL&lt;/a&gt;<br/>
        /// 
        /// </remarks>
        /// </summary>
        Task<Models.Requests.CreateMediaResponse> CreateMediaAsync(CreateMediaRequest request, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null);

        /// <summary>
        /// Upload media from device
        /// 
        /// <remarks>
        /// This endpoint enables accelerated uploads of large media files directly from your local device to FastPix for processing and storage.<br/>
        /// <br/>
        /// &gt; **NOTE**<br/>
        /// &gt;<br/>
        /// &gt; This version now supports uploads with no file size limitations and offers faster uploads. The previous endpoint (which had a 500MB size limit) is now deprecated. You can find details in the <a href="https://docs.fastpix.io/changelog/api-update-direct-upload-media-from-device">changelog</a>.<br/>
        /// <br/>
        /// #### How it works<br/>
        /// <br/>
        /// 1. Send a POST request to this endpoint with optional media settings.  <br/>
        /// <br/>
        /// 2. The response includes an `uploadId` and a signed `url` for direct video file upload.<br/>
        /// <br/>
        /// 3. Upload your video file to the provided url by making a PUT request. The API accepts the media file from your device and uploads it to the FastPix platform. (Refer to &lt;a href=&quot;https://docs.fastpix.io/docs/upload-videos-directly#step-3-initiate-the-upload&quot;&gt;Step 3: Initiate the upload&lt;/a&gt; for complete instructions.)<br/>
        /// <br/>
        /// <br/>
        /// 4. Once uploaded, the media undergoes processing and is assigned a unique ID for tracking. Retain this `uploadId` for any future operations related to this upload. <br/>
        /// <br/>
        /// <br/>
        /// <br/>
        /// After uploading, you can use the &lt;a href=&quot;https://docs.fastpix.io/reference/get-media&quot;&gt;Get Media by ID&lt;/a&gt; endpoint to check the status of the uploaded media asset and see if it has transitioned to a `Ready` status for playback. <br/>
        /// <br/>
        /// To notify your application about the status of this API request check for the webhooks for &lt;a href=&quot;https://docs.fastpix.io/docs/webhooks-collection#media-related-events&quot;&gt;media related events&lt;/a&gt;.  <br/>
        /// <br/>
        /// <br/>
        /// #### Example<br/>
        /// <br/>
        /// A social media platform allows users to upload video content directly from their phones or computers. This endpoint facilitates the upload process. For example, if you are developing a video-sharing app where users can upload short clips from their mobile devices, this endpoint enables them to select a video, upload it to the platform.<br/>
        /// <br/>
        /// Related guide: &lt;a href=&quot;https://docs.fastpix.io/docs/upload-videos-directly&quot;&gt;Upload videos directly&lt;/a&gt;<br/>
        /// 
        /// </remarks>
        /// </summary>
        Task<DirectUploadVideoMediaResponse> UploadAsync(DirectUploadVideoMediaRequest? request = null, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null);
    }

    public class InputVideo: IInputVideo
    {
        public SDKConfig SDKConfiguration { get; private set; }

        private const string _language = Constants.Language;
        private const string _sdkVersion = Constants.SdkVersion;
        private const string _sdkGenVersion = Constants.SdkGenVersion;
        private const string _openapiDocVersion = Constants.OpenApiDocVersion;

        public InputVideo(SDKConfig config)
        {
            SDKConfiguration = config;
        }

        public async Task<Models.Requests.CreateMediaResponse> CreateMediaAsync(CreateMediaRequest request, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null)
        {
            string baseUrl = this.SDKConfiguration.GetTemplatedServerUrl();

            var urlString = baseUrl + "/on-demand";

            var httpRequest = new HttpRequestMessage(HttpMethod.Post, urlString);
            httpRequest.Headers.Add("user-agent", SDKConfiguration.UserAgent);

            var serializedBody = RequestBodySerializer.Serialize(request, "Request", "json", false, false);
            if (serializedBody != null)
            {
                httpRequest.Content = serializedBody;
            }

            if (SDKConfiguration.SecuritySource != null)
            {
                httpRequest = new SecurityMetadata(SDKConfiguration.SecuritySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext(SDKConfiguration, baseUrl, "create-media", null, SDKConfiguration.SecuritySource, cancellationToken);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);
            if (retryConfig == null)
            {
                if (this.SDKConfiguration.RetryConfig != null)
                {
                    retryConfig = this.SDKConfiguration.RetryConfig;
                }
                else
                {
                    var backoff = new BackoffStrategy(
                        initialIntervalMs: 1000L,
                        maxIntervalMs: 10000L,
                        maxElapsedTimeMs: 3600000L,
                        exponent: 1.5
                    );
                    retryConfig = new RetryConfig(
                        strategy: RetryConfig.RetryStrategy.BACKOFF,
                        backoff: backoff,
                        retryConnectionErrors: true
                    );
                }
            }

            List<string> statusCodes = new List<string>
            {
                "408",
                "429",
                "500",
                "502",
                "503",
                "504",
            };

            Func<Task<HttpResponseMessage>> retrySend = async () =>
            {
                var _httpRequest = await SDKConfiguration.Client.CloneAsync(httpRequest);
                return await SDKConfiguration.Client.SendAsync(_httpRequest, cancellationToken);
            };
            var retries = new Fastpix.Utils.Retries.Retries(retrySend, retryConfig, statusCodes);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await retries.Run();
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 201)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    CreateMediaSuccessResponse obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<CreateMediaSuccessResponse>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into CreateMediaSuccessResponse.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new Models.Requests.CreateMediaResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.CreateMediaSuccessResponse = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    DefaultError obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<DefaultError>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into DefaultError.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new Models.Requests.CreateMediaResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.DefaultError = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
        }

        public async Task<DirectUploadVideoMediaResponse> UploadAsync(DirectUploadVideoMediaRequest? request = null, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null)
        {
            string baseUrl = this.SDKConfiguration.GetTemplatedServerUrl();

            var urlString = baseUrl + "/on-demand/upload";

            var httpRequest = new HttpRequestMessage(HttpMethod.Post, urlString);
            httpRequest.Headers.Add("user-agent", SDKConfiguration.UserAgent);

            var serializedBody = RequestBodySerializer.Serialize(request, "Request", "json", false, true);
            if (serializedBody != null)
            {
                httpRequest.Content = serializedBody;
            }

            if (SDKConfiguration.SecuritySource != null)
            {
                httpRequest = new SecurityMetadata(SDKConfiguration.SecuritySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext(SDKConfiguration, baseUrl, "direct-upload-video-media", null, SDKConfiguration.SecuritySource, cancellationToken);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);
            if (retryConfig == null)
            {
                if (this.SDKConfiguration.RetryConfig != null)
                {
                    retryConfig = this.SDKConfiguration.RetryConfig;
                }
                else
                {
                    var backoff = new BackoffStrategy(
                        initialIntervalMs: 1000L,
                        maxIntervalMs: 10000L,
                        maxElapsedTimeMs: 3600000L,
                        exponent: 1.5
                    );
                    retryConfig = new RetryConfig(
                        strategy: RetryConfig.RetryStrategy.BACKOFF,
                        backoff: backoff,
                        retryConnectionErrors: true
                    );
                }
            }

            List<string> statusCodes = new List<string>
            {
                "408",
                "429",
                "500",
                "502",
                "503",
                "504",
            };

            Func<Task<HttpResponseMessage>> retrySend = async () =>
            {
                var _httpRequest = await SDKConfiguration.Client.CloneAsync(httpRequest);
                return await SDKConfiguration.Client.SendAsync(_httpRequest, cancellationToken);
            };
            var retries = new Fastpix.Utils.Retries.Retries(retrySend, retryConfig, statusCodes);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await retries.Run();
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 201)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    DirectUploadVideoMediaResponseBody obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<DirectUploadVideoMediaResponseBody>(httpResponseBody, NullValueHandling.Include);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into DirectUploadVideoMediaResponseBody.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new DirectUploadVideoMediaResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.Object = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    DefaultError obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<DefaultError>(httpResponseBody, NullValueHandling.Include);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into DefaultError.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new DirectUploadVideoMediaResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.DefaultError = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
        }
    }
}