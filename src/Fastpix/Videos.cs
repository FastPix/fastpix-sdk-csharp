/* 
 * This file is auto-generated.
 * Do not edit this file manually.
 * Your changes will be overwritten during the next generation.
 */
#nullable enable
namespace Fastpix
{
    using Fastpix.Hooks;
    using Fastpix.Models.Components;
    using Fastpix.Models.Errors;
    using Fastpix.Models.Requests;
    using Fastpix.Utils;
    using Fastpix.Utils.Retries;
    using Newtonsoft.Json;
    using System;
    using System.Collections.Generic;
    using System.Net.Http;
    using System.Net.Http.Headers;
    using System.Threading;
    using System.Threading.Tasks;

    public interface IVideos
    {

        /// <summary>
        /// Get all clips of a live stream
        /// 
        /// <remarks>
        /// Retrieves a list of all media clips generated from a specific livestream. Each media entry includes metadata such as the clip media IDs, and other relevant details. A media clip is a segmented portion of an original media file (source live stream). Clips are often created for various purposes such as previews, highlights, or customized edits.<br/>
        /// #### How it works<br/>
        /// 1. Provide the livestreamId as a parameter when calling this endpoint.<br/>
        /// <br/>
        /// 2. The API returns a paginated list of media clips created from the specified livestream.<br/>
        /// <br/>
        /// 3. Pagination helps maintain performance and usability when handling large sets of media files, making it easier to organize and manage content in bulk.<br/>
        /// <br/>
        /// #### Use case<br/>
        /// Suppose you’re hosting a live gaming event and want to showcase key moments from the stream — such as top plays or final match highlights. You can use this endpoint to fetch all clips generated from that livestream, display them in your dashboard, or use them for post-event editing and sharing.<br/>
        /// <br/>
        /// <br/>
        /// Related guide: &lt;a href=&quot;https://docs.fastpix.io/docs/instant-live-clipping&quot;&gt;Instant live clipping&lt;/a&gt;<br/>
        /// 
        /// </remarks>
        /// </summary>
        Task<ListLiveClipsResponse> ListLiveClipsAsync(string livestreamId, long? limit = 10, long? offset = 1, SortOrder? orderBy = Fastpix.Models.Components.SortOrder.Desc, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null);

        /// <summary>
        /// Update a media by ID
        /// 
        /// <remarks>
        /// This endpoint allows you to update specific parameters of an existing media file. You can modify the key-value pairs of the metadata that were provided in the payload during the creation of media from a URL or when uploading the media directly from device. <br/>
        /// <br/>
        /// <br/>
        /// #### How it works<br/>
        /// <br/>
        /// 1. Make a PATCH request to this endpoint. Replace `&lt;mediaId&gt;` with the unique ID (`uploadId` or `id`) of the media you received after uploading to FastPix<br/>
        /// <br/>
        /// 2. Include the updated parameters in the request body.<br/>
        /// <br/>
        /// 3. The response returns the updated media data, confirming the changes. <br/>
        /// <br/>
        /// 4. Monitor the &lt;a href=&quot;https://docs.fastpix.io/docs/media-events#videomediaupdated&quot;&gt;video.media.updated&lt;/a&gt; webhook event to track the update status in your system.<br/>
        /// <br/>
        /// #### Example<br/>
        /// If a user uploads a video and later needs to change the title, add a new description, or update tags, you can use this endpoint to update the media metadata without re-uploading the entire video.<br/>
        /// 
        /// </remarks>
        /// </summary>
        Task<UpdatedMediaResponse> UpdateAsync(string mediaId, UpdatedMediaRequestBody body, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null);

        /// <summary>
        /// Update audio / subtitle track
        /// 
        /// <remarks>
        /// This endpoint allows you to update an existing audio or subtitle track associated with a media file. When updating a track, you must provide the new track `url`, `languageName`, and `languageCode`, ensuring all three parameters are included in the request.<br/>
        /// <br/>
        /// <br/>
        /// #### How it works<br/>
        /// <br/>
        /// 1. Send a PATCH request to this endpoint, replacing `{mediaId}` with the media ID, and `{trackId}` with the ID of the track you want to update.<br/>
        /// <br/>
        /// 2. Provide the necessary details in the request body.<br/>
        /// <br/>
        /// 3. Receive a response confirming the track update.<br/>
        /// <br/>
        /// #### Webhook Events<br/>
        /// <br/>
        /// After updating a track, your system must receive webhook notifications:<br/>
        /// <br/>
        /// 1. After successfully updating a track, your system must receive the webhook event &lt;a href=&quot;https://docs.fastpix.io/docs/transform-media-events#videomediatrackupdated&quot;&gt;video.media.track.updated&lt;/a&gt;.<br/>
        /// <br/>
        /// 2. Once the new track is processed and ready, you must receive the webhook event &lt;a href=&quot;https://docs.fastpix.io/docs/transform-media-events#videomediatrackready&quot;&gt;video.media.track.ready&lt;/a&gt;.<br/>
        /// <br/>
        /// 3. Once the media file is updated with the new track details, a &lt;a href=&quot;https://docs.fastpix.io/docs/media-events#videomediaupdated&quot;&gt;video.media.updated&lt;/a&gt; event must be triggered.<br/>
        /// <br/>
        /// <br/>
        /// #### Example<br/>
        /// Suppose you previously added a French subtitle track to a video but now need to update it with a different file. By calling this API, you can replace the existing subtitle file (.vtt) with a new one while keeping the same track ID. This is useful when:<br/>
        /// <br/>
        ///   - The original track file has errors and needs correction.<br/>
        ///   - You want to improve subtitle translations or replace an audio track with a better-quality version.<br/>
        /// <br/>
        /// Related guides: &lt;a href=&quot;https://docs.fastpix.io/docs/manage-subtitle-tracks&quot;&gt;Add own subtitle tracks&lt;/a&gt;, &lt;a href=&quot;https://docs.fastpix.io/docs/manage-audio-tracks&quot;&gt;Add own audio tracks&lt;/a&gt;<br/>
        /// 
        /// </remarks>
        /// </summary>
        Task<UpdateMediaTrackResponse> UpdateTrackAsync(string trackId, string mediaId, UpdateTrackRequest body, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null);

        /// <summary>
        /// Get the summary of a video
        /// 
        /// <remarks>
        /// This endpoint returns the generated summary of a video.  <br/>
        /// <br/>
        /// The summary is created using the **InVideo Summary** feature, which processes the video content and produces a textual summary.  <br/>
        /// <br/>
        /// To use this endpoint, you must first generate the video summary using the Generate Video Summary endpoint. This endpoint can return the summary only after that process is complete. <br/>
        /// <br/>
        /// Typical use cases include:  <br/>
        /// - Providing viewers with a quick preview of the video&apos;s main content.  <br/>
        /// - Enabling search or recommendation systems to surface summarized insights.  <br/>
        /// - Supporting accessibility and content discovery without requiring users to watch the full video.  <br/>
        /// <br/>
        /// If the summary has not been generated or the feature is disabled for the requested media, the endpoint returns an error indicating that the summary is unavailable. <br/>
        /// 
        /// </remarks>
        /// </summary>
        Task<GetMediaSummaryResponse> GetSummaryAsync(string mediaId, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null);

        /// <summary>
        /// Get info of media inputs
        /// 
        /// <remarks>
        /// This endpoint lets you retrieve detailed information about the media inputs associated with a specific media item. You can use it to verify the media file’s input URL, track its creation status, and check its container format. You must provide the mediaId (either the uploadId or the id) to fetch this information.<br/>
        /// <br/>
        /// <br/>
        /// #### How it works<br/>
        /// <br/>
        /// Upon making a `GET` request with the mediaId, FastPix returns a response with: <br/>
        /// <br/>
        /// * The public storage input `url` of the uploaded media file. <br/>
        /// <br/>
        /// * Information about the media’s video and audio tracks, including whether they were successfully created.<br/>
        /// <br/>
        /// * The container format of the uploaded media file (for example, MP4, MKV).<br/>
        /// <br/>
        /// This endpoint is particularly useful for ensuring that all necessary tracks (video and audio) have been correctly associated with the media during the upload or media creation process.<br/>
        /// 
        /// </remarks>
        /// </summary>
        Task<RetrieveMediaInputInfoResponse> GetInputInfoAsync(string mediaId, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null);
    }

    public class Videos: IVideos
    {
        public SDKConfig SDKConfiguration { get; private set; }

        private const string _language = Constants.Language;
        private const string _sdkVersion = Constants.SdkVersion;
        private const string _sdkGenVersion = Constants.SdkGenVersion;
        private const string _openapiDocVersion = Constants.OpenApiDocVersion;

        public Videos(SDKConfig config)
        {
            SDKConfiguration = config;
        }

        public async Task<ListLiveClipsResponse> ListLiveClipsAsync(string livestreamId, long? limit = 10, long? offset = 1, SortOrder? orderBy = Fastpix.Models.Components.SortOrder.Desc, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null)
        {
            var request = new ListLiveClipsRequest()
            {
                LivestreamId = livestreamId,
                Limit = limit,
                Offset = offset,
                OrderBy = orderBy,
            };
            string baseUrl = this.SDKConfiguration.GetTemplatedServerUrl();
            var urlString = URLBuilder.Build(baseUrl, "/on-demand/{livestreamId}/live-clips", request, null);

            var httpRequest = new HttpRequestMessage(HttpMethod.Get, urlString);
            httpRequest.Headers.Add("user-agent", SDKConfiguration.UserAgent);

            if (SDKConfiguration.SecuritySource != null)
            {
                httpRequest = new SecurityMetadata(SDKConfiguration.SecuritySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext(SDKConfiguration, baseUrl, "list-live-clips", null, SDKConfiguration.SecuritySource, cancellationToken);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);
            if (retryConfig == null)
            {
                if (this.SDKConfiguration.RetryConfig != null)
                {
                    retryConfig = this.SDKConfiguration.RetryConfig;
                }
                else
                {
                    var backoff = new BackoffStrategy(
                        initialIntervalMs: 1000L,
                        maxIntervalMs: 10000L,
                        maxElapsedTimeMs: 3600000L,
                        exponent: 1.5
                    );
                    retryConfig = new RetryConfig(
                        strategy: RetryConfig.RetryStrategy.BACKOFF,
                        backoff: backoff,
                        retryConnectionErrors: true
                    );
                }
            }

            List<string> statusCodes = new List<string>
            {
                "408",
                "429",
                "500",
                "502",
                "503",
                "504",
            };

            Func<Task<HttpResponseMessage>> retrySend = async () =>
            {
                var _httpRequest = await SDKConfiguration.Client.CloneAsync(httpRequest);
                return await SDKConfiguration.Client.SendAsync(_httpRequest, cancellationToken);
            };
            var retries = new Fastpix.Utils.Retries.Retries(retrySend, retryConfig, statusCodes);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await retries.Run();
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ListLiveClipsResponseBody obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<ListLiveClipsResponseBody>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ListLiveClipsResponseBody.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new ListLiveClipsResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.Object = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    DefaultError obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<DefaultError>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into DefaultError.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new ListLiveClipsResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.DefaultError = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
        }

        public async Task<UpdatedMediaResponse> UpdateAsync(string mediaId, UpdatedMediaRequestBody body, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null)
        {
            var request = new UpdatedMediaRequest()
            {
                MediaId = mediaId,
                Body = body,
            };
            string baseUrl = this.SDKConfiguration.GetTemplatedServerUrl();
            var urlString = URLBuilder.Build(baseUrl, "/on-demand/{mediaId}", request, null);

            var httpRequest = new HttpRequestMessage(HttpMethod.Patch, urlString);
            httpRequest.Headers.Add("user-agent", SDKConfiguration.UserAgent);

            var serializedBody = RequestBodySerializer.Serialize(request, "Body", "json", false, false);
            if (serializedBody != null)
            {
                httpRequest.Content = serializedBody;
            }

            if (SDKConfiguration.SecuritySource != null)
            {
                httpRequest = new SecurityMetadata(SDKConfiguration.SecuritySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext(SDKConfiguration, baseUrl, "updated-media", null, SDKConfiguration.SecuritySource, cancellationToken);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);
            if (retryConfig == null)
            {
                if (this.SDKConfiguration.RetryConfig != null)
                {
                    retryConfig = this.SDKConfiguration.RetryConfig;
                }
                else
                {
                    var backoff = new BackoffStrategy(
                        initialIntervalMs: 1000L,
                        maxIntervalMs: 10000L,
                        maxElapsedTimeMs: 3600000L,
                        exponent: 1.5
                    );
                    retryConfig = new RetryConfig(
                        strategy: RetryConfig.RetryStrategy.BACKOFF,
                        backoff: backoff,
                        retryConnectionErrors: true
                    );
                }
            }

            List<string> statusCodes = new List<string>
            {
                "408",
                "429",
                "500",
                "502",
                "503",
                "504",
            };

            Func<Task<HttpResponseMessage>> retrySend = async () =>
            {
                var _httpRequest = await SDKConfiguration.Client.CloneAsync(httpRequest);
                return await SDKConfiguration.Client.SendAsync(_httpRequest, cancellationToken);
            };
            var retries = new Fastpix.Utils.Retries.Retries(retrySend, retryConfig, statusCodes);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await retries.Run();
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    UpdatedMediaResponseBody obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<UpdatedMediaResponseBody>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into UpdatedMediaResponseBody.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new UpdatedMediaResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.Object = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    DefaultError obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<DefaultError>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into DefaultError.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new UpdatedMediaResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.DefaultError = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
        }

        public async Task<UpdateMediaTrackResponse> UpdateTrackAsync(string trackId, string mediaId, UpdateTrackRequest body, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null)
        {
            var request = new UpdateMediaTrackRequest()
            {
                TrackId = trackId,
                MediaId = mediaId,
                Body = body,
            };
            string baseUrl = this.SDKConfiguration.GetTemplatedServerUrl();
            var urlString = URLBuilder.Build(baseUrl, "/on-demand/{mediaId}/tracks/{trackId}", request, null);

            var httpRequest = new HttpRequestMessage(HttpMethod.Patch, urlString);
            httpRequest.Headers.Add("user-agent", SDKConfiguration.UserAgent);

            var serializedBody = RequestBodySerializer.Serialize(request, "Body", "json", false, false);
            if (serializedBody != null)
            {
                httpRequest.Content = serializedBody;
            }

            if (SDKConfiguration.SecuritySource != null)
            {
                httpRequest = new SecurityMetadata(SDKConfiguration.SecuritySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext(SDKConfiguration, baseUrl, "update-media-track", null, SDKConfiguration.SecuritySource, cancellationToken);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);
            if (retryConfig == null)
            {
                if (this.SDKConfiguration.RetryConfig != null)
                {
                    retryConfig = this.SDKConfiguration.RetryConfig;
                }
                else
                {
                    var backoff = new BackoffStrategy(
                        initialIntervalMs: 1000L,
                        maxIntervalMs: 10000L,
                        maxElapsedTimeMs: 3600000L,
                        exponent: 1.5
                    );
                    retryConfig = new RetryConfig(
                        strategy: RetryConfig.RetryStrategy.BACKOFF,
                        backoff: backoff,
                        retryConnectionErrors: true
                    );
                }
            }

            List<string> statusCodes = new List<string>
            {
                "408",
                "429",
                "500",
                "502",
                "503",
                "504",
            };

            Func<Task<HttpResponseMessage>> retrySend = async () =>
            {
                var _httpRequest = await SDKConfiguration.Client.CloneAsync(httpRequest);
                return await SDKConfiguration.Client.SendAsync(_httpRequest, cancellationToken);
            };
            var retries = new Fastpix.Utils.Retries.Retries(retrySend, retryConfig, statusCodes);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await retries.Run();
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    UpdateMediaTrackResponseBody obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<UpdateMediaTrackResponseBody>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into UpdateMediaTrackResponseBody.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new UpdateMediaTrackResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.Object = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    DefaultError obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<DefaultError>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into DefaultError.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new UpdateMediaTrackResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.DefaultError = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
        }

        public async Task<GetMediaSummaryResponse> GetSummaryAsync(string mediaId, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null)
        {
            var request = new GetMediaSummaryRequest()
            {
                MediaId = mediaId,
            };
            string baseUrl = this.SDKConfiguration.GetTemplatedServerUrl();
            var urlString = URLBuilder.Build(baseUrl, "/on-demand/{mediaId}/summary", request, null);

            var httpRequest = new HttpRequestMessage(HttpMethod.Get, urlString);
            httpRequest.Headers.Add("user-agent", SDKConfiguration.UserAgent);

            if (SDKConfiguration.SecuritySource != null)
            {
                httpRequest = new SecurityMetadata(SDKConfiguration.SecuritySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext(SDKConfiguration, baseUrl, "get-media-summary", null, SDKConfiguration.SecuritySource, cancellationToken);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);
            if (retryConfig == null)
            {
                if (this.SDKConfiguration.RetryConfig != null)
                {
                    retryConfig = this.SDKConfiguration.RetryConfig;
                }
                else
                {
                    var backoff = new BackoffStrategy(
                        initialIntervalMs: 1000L,
                        maxIntervalMs: 10000L,
                        maxElapsedTimeMs: 3600000L,
                        exponent: 1.5
                    );
                    retryConfig = new RetryConfig(
                        strategy: RetryConfig.RetryStrategy.BACKOFF,
                        backoff: backoff,
                        retryConnectionErrors: true
                    );
                }
            }

            List<string> statusCodes = new List<string>
            {
                "408",
                "429",
                "500",
                "502",
                "503",
                "504",
            };

            Func<Task<HttpResponseMessage>> retrySend = async () =>
            {
                var _httpRequest = await SDKConfiguration.Client.CloneAsync(httpRequest);
                return await SDKConfiguration.Client.SendAsync(_httpRequest, cancellationToken);
            };
            var retries = new Fastpix.Utils.Retries.Retries(retrySend, retryConfig, statusCodes);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await retries.Run();
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    GetMediaSummaryResponseBody obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<GetMediaSummaryResponseBody>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into GetMediaSummaryResponseBody.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new GetMediaSummaryResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.Object = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    DefaultError obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<DefaultError>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into DefaultError.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new GetMediaSummaryResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.DefaultError = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
        }

        public async Task<RetrieveMediaInputInfoResponse> GetInputInfoAsync(string mediaId, RetryConfig? retryConfig = null, CancellationToken? cancellationToken = null)
        {
            var request = new RetrieveMediaInputInfoRequest()
            {
                MediaId = mediaId,
            };
            string baseUrl = this.SDKConfiguration.GetTemplatedServerUrl();
            var urlString = URLBuilder.Build(baseUrl, "/on-demand/{mediaId}/input-info", request, null);

            var httpRequest = new HttpRequestMessage(HttpMethod.Get, urlString);
            httpRequest.Headers.Add("user-agent", SDKConfiguration.UserAgent);

            if (SDKConfiguration.SecuritySource != null)
            {
                httpRequest = new SecurityMetadata(SDKConfiguration.SecuritySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext(SDKConfiguration, baseUrl, "retrieveMediaInputInfo", null, SDKConfiguration.SecuritySource, cancellationToken);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);
            if (retryConfig == null)
            {
                if (this.SDKConfiguration.RetryConfig != null)
                {
                    retryConfig = this.SDKConfiguration.RetryConfig;
                }
                else
                {
                    var backoff = new BackoffStrategy(
                        initialIntervalMs: 1000L,
                        maxIntervalMs: 10000L,
                        maxElapsedTimeMs: 3600000L,
                        exponent: 1.5
                    );
                    retryConfig = new RetryConfig(
                        strategy: RetryConfig.RetryStrategy.BACKOFF,
                        backoff: backoff,
                        retryConnectionErrors: true
                    );
                }
            }

            List<string> statusCodes = new List<string>
            {
                "408",
                "429",
                "500",
                "502",
                "503",
                "504",
            };

            Func<Task<HttpResponseMessage>> retrySend = async () =>
            {
                var _httpRequest = await SDKConfiguration.Client.CloneAsync(httpRequest);
                return await SDKConfiguration.Client.SendAsync(_httpRequest, cancellationToken);
            };
            var retries = new Fastpix.Utils.Retries.Retries(retrySend, retryConfig, statusCodes);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await retries.Run();
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    RetrieveMediaInputInfoResponseBody obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<RetrieveMediaInputInfoResponseBody>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into RetrieveMediaInputInfoResponseBody.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new RetrieveMediaInputInfoResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.Object = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.APIException("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    DefaultError obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<DefaultError>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into DefaultError.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new RetrieveMediaInputInfoResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.DefaultError = obj;
                    return response;
                }

                throw new Models.Errors.APIException("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
        }
    }
}